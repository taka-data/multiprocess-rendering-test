# multiprocess-rendering-test

1動画に対して、シングルタスクでレンダリングを行った時の速度測定と
マルチタスクで行った場合について比較して行く。

# python2系について
詳しく書かれた２系の記事が見当たらなかったが、並列処理は、あまり得意ではなかったように思われる。
２系では、並列処理にはmultiprocessingで行われているとする。

# multiprocessing とは
pythonで非同期処理を行うためのライブラリ。非同期処理ではあるが、実行の一貫性を保つためにGILという仕組みが存在し、その結果としてマルチスレッドによる実行ができていない。

# GILとは
Python(のReference ImplementationであるCPython)は、マルチスレッドに対応していますが、スレッドセーフティを確保するためにGIL(Global Interpretation Lock)が存在する。

multiprocessingではこの影響を強く受け、高速化に向いていない。

# concurrent.futures とは

GILによる弊害を考慮し、非同期処理をうまく行っているライブラリ
3.6あたりから登場したライブラリ。

# テスト
単純なループ、GILの影響を受けるmultiprocessing
GILの影響を受けないマルチスレッドループで速度比較を行った。それぞれ３回計測を行った。
OpenCVで動画を読み込み、ループの番号を描画して行くといった単純作業を行なっている。
ちなみに読み取った動画は12秒　25fpsほどの動画である。

## 単純なループ
単純なforループで速度を測ったところ1.50, 1.60, 1.70秒といった実行時間であった。

## GILの影響を受けるmultiprocessing
GILの影響を受けるmultiprocessingで速度を測ったところ2.32, 2.76, 2.58秒といった実行時間であった.
これはGILによって、スレッドを切り替えているため実行時間にforループよりも時間がかかっている。

## GILの影響を受けないマルチスレッドループ
GILの影響を受けないマルチスレッドループで速度を測ったところ0.09, 0.09, 0.09秒といった実行時間であった。こちらはGILの影響を受けずに２スレッドでうまく並列演算できているのでかなりの高速化が実現された。

# まとめ
高速化を目的とした非同期処理にはconcurrent.futuresがおすすめである。

# 参考文献
オライリー社　Brett Slatkin著　"Effective Python"